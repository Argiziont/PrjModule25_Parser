/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.11.1.0 (NJsonSchema v10.4.3.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class CategoryClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    getAll(): Promise<ResponseCategory[]> {
        let url_ = this.baseUrl + "/Category/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ResponseCategory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getPaged(page: number | undefined, rowsPerPage: number | undefined): Promise<ResponseCategory[]> {
        let url_ = this.baseUrl + "/Category/GetPaged?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (rowsPerPage === null)
            throw new Error("The parameter 'rowsPerPage' cannot be null.");
        else if (rowsPerPage !== undefined)
            url_ += "rowsPerPage=" + encodeURIComponent("" + rowsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPaged(_response);
        });
    }

    protected processGetPaged(response: Response): Promise<ResponseCategory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getAllNested(): Promise<ResponseNestedCategory> {
        let url_ = this.baseUrl + "/Category/GetAllNested";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllNested(_response);
        });
    }

    protected processGetAllNested(response: Response): Promise<ResponseNestedCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseNestedCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getNestedByParentId(id: number | undefined): Promise<ResponseCategory[]> {
        let url_ = this.baseUrl + "/Category/GetNestedByParentId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNestedByParentId(_response);
        });
    }

    protected processGetNestedByParentId(response: Response): Promise<ResponseCategory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getNestedByParentIdAndCompanyId(id: number | undefined, companyId: number | undefined): Promise<ResponseCategory[]> {
        let url_ = this.baseUrl + "/Category/GetNestedByParentIdAndCompanyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNestedByParentIdAndCompanyId(_response);
        });
    }

    protected processGetNestedByParentIdAndCompanyId(response: Response): Promise<ResponseCategory[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseCategory.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getProductCountByCategoryIdAndCompanyId(id: number | undefined, companyId: number | undefined): Promise<number> {
        let url_ = this.baseUrl + "/Category/GetProductCountByCategoryIdAndCompanyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductCountByCategoryIdAndCompanyId(_response);
        });
    }

    protected processGetProductCountByCategoryIdAndCompanyId(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getProductCountByCategoryId(id: number | undefined): Promise<number> {
        let url_ = this.baseUrl + "/Category/GetProductCountByCategoryId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductCountByCategoryId(_response);
        });
    }

    protected processGetProductCountByCategoryId(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class CompanyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    parseCompanyPageProducts(companyName: string | null | undefined): Promise<ProductData[]> {
        let url_ = this.baseUrl + "/Company/ParseCompanyPageProducts?";
        if (companyName !== undefined && companyName !== null)
            url_ += "companyName=" + encodeURIComponent("" + companyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParseCompanyPageProducts(_response);
        });
    }

    protected processParseCompanyPageProducts(response: Response): Promise<ProductData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = Exception.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    addByUrl(companyUrl: string | null | undefined): Promise<ResponseCompany> {
        let url_ = this.baseUrl + "/Company/AddByUrl?";
        if (companyUrl !== undefined && companyUrl !== null)
            url_ += "companyUrl=" + encodeURIComponent("" + companyUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddByUrl(_response);
        });
    }

    protected processAddByUrl(response: Response): Promise<ResponseCompany> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseCompany.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = Exception.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getById(id: number | undefined): Promise<ResponseCompany> {
        let url_ = this.baseUrl + "/Company/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<ResponseCompany> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseCompany.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getAll(): Promise<ResponseCompany[]> {
        let url_ = this.baseUrl + "/Company/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ResponseCompany[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseCompany.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class ProductClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:5001";
    }

    parseDataInsideProductPage(productUrl: string | null | undefined): Promise<ProductData> {
        let url_ = this.baseUrl + "/Product/GetParsedProductPage?";
        if (productUrl !== undefined && productUrl !== null)
            url_ += "productUrl=" + encodeURIComponent("" + productUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParseDataInsideProductPage(_response);
        });
    }

    protected processParseDataInsideProductPage(response: Response): Promise<ProductData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductData.fromJS(resultData200);
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    parseAllProductUrlsInsideCompanyPage(companyName: string | null | undefined): Promise<ProductData[]> {
        let url_ = this.baseUrl + "/Product/ParseAllProductUrlsInsideCompanyPage?";
        if (companyName !== undefined && companyName !== null)
            url_ += "companyName=" + encodeURIComponent("" + companyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParseAllProductUrlsInsideCompanyPage(_response);
        });
    }

    protected processParseAllProductUrlsInsideCompanyPage(response: Response): Promise<ProductData[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductData.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    parseSingleProductInsideCompanyPage(productId: string | null | undefined): Promise<ProductData> {
        let url_ = this.baseUrl + "/Product/ParseSingleProductInsideCompanyPage?";
        if (productId !== undefined && productId !== null)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processParseSingleProductInsideCompanyPage(_response);
        });
    }

    protected processParseSingleProductInsideCompanyPage(response: Response): Promise<ProductData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductData.fromJS(resultData200);
            return result200;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = resultData202 !== undefined ? resultData202 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result202);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 !== undefined ? resultData400 : <any>null;
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getFullProductsById(id: number | undefined): Promise<ProductJson> {
        let url_ = this.baseUrl + "/Product/GetFullProductsById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFullProductsById(_response);
        });
    }

    protected processGetFullProductsById(response: Response): Promise<ProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getProductsByCompanyId(id: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetProductsByCompanyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductsByCompanyId(_response);
        });
    }

    protected processGetProductsByCompanyId(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getProductsByCategoryId(id: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetProductsByCategoryId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductsByCategoryId(_response);
        });
    }

    protected processGetProductsByCategoryId(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getPagedProductsByCompanyId(id: number | undefined, page: number | undefined, rowsPerPage: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetPagedProductsByCompanyId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (rowsPerPage === null)
            throw new Error("The parameter 'rowsPerPage' cannot be null.");
        else if (rowsPerPage !== undefined)
            url_ += "rowsPerPage=" + encodeURIComponent("" + rowsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPagedProductsByCompanyId(_response);
        });
    }

    protected processGetPagedProductsByCompanyId(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getPagedProducts(page: number | undefined, rowsPerPage: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetPagedProducts?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (rowsPerPage === null)
            throw new Error("The parameter 'rowsPerPage' cannot be null.");
        else if (rowsPerPage !== undefined)
            url_ += "rowsPerPage=" + encodeURIComponent("" + rowsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPagedProducts(_response);
        });
    }

    protected processGetPagedProducts(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getPagedProductsByCategoryId(id: number | undefined, page: number | undefined, rowsPerPage: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetPagedProductsByCategoryId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (rowsPerPage === null)
            throw new Error("The parameter 'rowsPerPage' cannot be null.");
        else if (rowsPerPage !== undefined)
            url_ += "rowsPerPage=" + encodeURIComponent("" + rowsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPagedProductsByCategoryId(_response);
        });
    }

    protected processGetPagedProductsByCategoryId(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getPagedProductsByCategoryIdAndCompanyId(categoryId: number | undefined, companyId: number | undefined, page: number | undefined, rowsPerPage: number | undefined): Promise<ResponseProduct[]> {
        let url_ = this.baseUrl + "/Product/GetPagedProductsByCategoryIdAndCompanyId?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (companyId === null)
            throw new Error("The parameter 'companyId' cannot be null.");
        else if (companyId !== undefined)
            url_ += "companyId=" + encodeURIComponent("" + companyId) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (rowsPerPage === null)
            throw new Error("The parameter 'rowsPerPage' cannot be null.");
        else if (rowsPerPage !== undefined)
            url_ += "rowsPerPage=" + encodeURIComponent("" + rowsPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPagedProductsByCategoryIdAndCompanyId(_response);
        });
    }

    protected processGetPagedProductsByCategoryIdAndCompanyId(response: Response): Promise<ResponseProduct[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProduct.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = Exception.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }

    getTotalProductCount(): Promise<number> {
        let url_ = this.baseUrl + "/Product/GetTotalProductCount";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTotalProductCount(_response);
        });
    }

    protected processGetTotalProductCount(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else {
            return response.text().then((_responseText) => {
            let resultdefault: any = null;
            let resultDatadefault = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            resultdefault = ProblemDetails.fromJS(resultDatadefault);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            });
        }
    }
}

export class ResponseCategory implements IResponseCategory {
    id?: number;
    name?: string | undefined;
    href?: string | undefined;
    productsCount?: string | undefined;

    constructor(data?: IResponseCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.href = _data["href"];
            this.productsCount = _data["productsCount"];
        }
    }

    static fromJS(data: any): ResponseCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["href"] = this.href;
        data["productsCount"] = this.productsCount;
        return data; 
    }
}

export interface IResponseCategory {
    id?: number;
    name?: string | undefined;
    href?: string | undefined;
    productsCount?: string | undefined;
}

export class Exception implements IException {
    stackTrace?: string | undefined;
    message?: string;
    innerException?: Exception | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stackTrace = _data["StackTrace"];
            this.message = _data["Message"];
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.source = _data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["StackTrace"] = this.stackTrace;
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["Source"] = this.source;
        return data; 
    }
}

export interface IException {
    stackTrace?: string | undefined;
    message?: string;
    innerException?: Exception | undefined;
    source?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class ResponseNestedCategory extends ResponseCategory implements IResponseNestedCategory {
    subCategories?: ResponseNestedCategory[] | undefined;

    constructor(data?: IResponseNestedCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(ResponseNestedCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseNestedCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseNestedCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IResponseNestedCategory extends IResponseCategory {
    subCategories?: ResponseNestedCategory[] | undefined;
}

export class ProductData implements IProductData {
    id?: number;
    companyId?: number | undefined;
    externalId?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    expirationDate?: Date;
    productState?: ProductState;
    description?: string | undefined;
    price?: string | undefined;
    keyWords?: string | undefined;
    jsonData?: string | undefined;
    jsonDataSchema?: string | undefined;
    company?: CompanyData | undefined;
    presence?: PresenceData | undefined;
    categories?: Category[] | undefined;
    productPaymentOptions?: ProductPaymentOption[] | undefined;
    productDeliveryOptions?: ProductDeliveryOption[] | undefined;
    productAttribute?: ProductAttribute[] | undefined;

    constructor(data?: IProductData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyId = _data["companyId"];
            this.externalId = _data["externalId"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.productState = _data["productState"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.keyWords = _data["keyWords"];
            this.jsonData = _data["jsonData"];
            this.jsonDataSchema = _data["jsonDataSchema"];
            this.company = _data["company"] ? CompanyData.fromJS(_data["company"]) : <any>undefined;
            this.presence = _data["presence"] ? PresenceData.fromJS(_data["presence"]) : <any>undefined;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["productPaymentOptions"])) {
                this.productPaymentOptions = [] as any;
                for (let item of _data["productPaymentOptions"])
                    this.productPaymentOptions!.push(ProductPaymentOption.fromJS(item));
            }
            if (Array.isArray(_data["productDeliveryOptions"])) {
                this.productDeliveryOptions = [] as any;
                for (let item of _data["productDeliveryOptions"])
                    this.productDeliveryOptions!.push(ProductDeliveryOption.fromJS(item));
            }
            if (Array.isArray(_data["productAttribute"])) {
                this.productAttribute = [] as any;
                for (let item of _data["productAttribute"])
                    this.productAttribute!.push(ProductAttribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductData {
        data = typeof data === 'object' ? data : {};
        let result = new ProductData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyId"] = this.companyId;
        data["externalId"] = this.externalId;
        data["title"] = this.title;
        data["url"] = this.url;
        data["syncDate"] = this.syncDate ? this.syncDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["productState"] = this.productState;
        data["description"] = this.description;
        data["price"] = this.price;
        data["keyWords"] = this.keyWords;
        data["jsonData"] = this.jsonData;
        data["jsonDataSchema"] = this.jsonDataSchema;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["presence"] = this.presence ? this.presence.toJSON() : <any>undefined;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.productPaymentOptions)) {
            data["productPaymentOptions"] = [];
            for (let item of this.productPaymentOptions)
                data["productPaymentOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productDeliveryOptions)) {
            data["productDeliveryOptions"] = [];
            for (let item of this.productDeliveryOptions)
                data["productDeliveryOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productAttribute)) {
            data["productAttribute"] = [];
            for (let item of this.productAttribute)
                data["productAttribute"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductData {
    id?: number;
    companyId?: number | undefined;
    externalId?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    expirationDate?: Date;
    productState?: ProductState;
    description?: string | undefined;
    price?: string | undefined;
    keyWords?: string | undefined;
    jsonData?: string | undefined;
    jsonDataSchema?: string | undefined;
    company?: CompanyData | undefined;
    presence?: PresenceData | undefined;
    categories?: Category[] | undefined;
    productPaymentOptions?: ProductPaymentOption[] | undefined;
    productDeliveryOptions?: ProductDeliveryOption[] | undefined;
    productAttribute?: ProductAttribute[] | undefined;
}

export enum ProductState {
    Idle = 0,
    Success = 1,
    Failed = 2,
}

export class CompanyData implements ICompanyData {
    id?: number;
    sourceId?: number | undefined;
    externalId?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    companyState?: CompanyState;
    jsonData?: string | undefined;
    jsonDataSchema?: string | undefined;
    products?: ProductData[] | undefined;
    source?: CompanySource | undefined;

    constructor(data?: ICompanyData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceId = _data["sourceId"];
            this.externalId = _data["externalId"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.companyState = _data["companyState"];
            this.jsonData = _data["jsonData"];
            this.jsonDataSchema = _data["jsonDataSchema"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductData.fromJS(item));
            }
            this.source = _data["source"] ? CompanySource.fromJS(_data["source"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyData {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceId"] = this.sourceId;
        data["externalId"] = this.externalId;
        data["name"] = this.name;
        data["url"] = this.url;
        data["syncDate"] = this.syncDate ? this.syncDate.toISOString() : <any>undefined;
        data["companyState"] = this.companyState;
        data["jsonData"] = this.jsonData;
        data["jsonDataSchema"] = this.jsonDataSchema;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyData {
    id?: number;
    sourceId?: number | undefined;
    externalId?: string | undefined;
    name?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    companyState?: CompanyState;
    jsonData?: string | undefined;
    jsonDataSchema?: string | undefined;
    products?: ProductData[] | undefined;
    source?: CompanySource | undefined;
}

export enum CompanyState {
    Idle = 0,
    Processing = 1,
    Success = 2,
    Failed = 3,
}

export class CompanySource implements ICompanySource {
    id?: number;
    name?: string | undefined;
    companies?: CompanyData[] | undefined;

    constructor(data?: ICompanySource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["companies"])) {
                this.companies = [] as any;
                for (let item of _data["companies"])
                    this.companies!.push(CompanyData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanySource {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.companies)) {
            data["companies"] = [];
            for (let item of this.companies)
                data["companies"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompanySource {
    id?: number;
    name?: string | undefined;
    companies?: CompanyData[] | undefined;
}

export class PresenceData implements IPresenceData {
    presenceSureAvailable?: boolean;
    orderAvailable?: boolean;
    available?: boolean;
    title?: string | undefined;
    ending?: boolean;
    waiting?: boolean;
    id?: number;
    productId?: number;
    product?: ProductData | undefined;

    constructor(data?: IPresenceData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.presenceSureAvailable = _data["presenceSureAvailable"];
            this.orderAvailable = _data["orderAvailable"];
            this.available = _data["available"];
            this.title = _data["title"];
            this.ending = _data["ending"];
            this.waiting = _data["waiting"];
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductData.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PresenceData {
        data = typeof data === 'object' ? data : {};
        let result = new PresenceData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["presenceSureAvailable"] = this.presenceSureAvailable;
        data["orderAvailable"] = this.orderAvailable;
        data["available"] = this.available;
        data["title"] = this.title;
        data["ending"] = this.ending;
        data["waiting"] = this.waiting;
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPresenceData {
    presenceSureAvailable?: boolean;
    orderAvailable?: boolean;
    available?: boolean;
    title?: string | undefined;
    ending?: boolean;
    waiting?: boolean;
    id?: number;
    productId?: number;
    product?: ProductData | undefined;
}

export class Category implements ICategory {
    id?: number;
    name?: string | undefined;
    url?: string | undefined;
    products?: ProductData[] | undefined;
    supCategory?: Category | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.url = _data["url"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductData.fromJS(item));
            }
            this.supCategory = _data["supCategory"] ? Category.fromJS(_data["supCategory"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["url"] = this.url;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["supCategory"] = this.supCategory ? this.supCategory.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICategory {
    id?: number;
    name?: string | undefined;
    url?: string | undefined;
    products?: ProductData[] | undefined;
    supCategory?: Category | undefined;
}

export class ProductPaymentOption implements IProductPaymentOption {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    optionName?: string | undefined;
    optionsComment?: string | undefined;
    product?: ProductData | undefined;

    constructor(data?: IProductPaymentOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.externalId = _data["externalId"];
            this.optionName = _data["optionName"];
            this.optionsComment = _data["optionsComment"];
            this.product = _data["product"] ? ProductData.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductPaymentOption {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPaymentOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["externalId"] = this.externalId;
        data["optionName"] = this.optionName;
        data["optionsComment"] = this.optionsComment;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductPaymentOption {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    optionName?: string | undefined;
    optionsComment?: string | undefined;
    product?: ProductData | undefined;
}

export class ProductDeliveryOption implements IProductDeliveryOption {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    optionName?: string | undefined;
    optionsComment?: string | undefined;
    product?: ProductData | undefined;

    constructor(data?: IProductDeliveryOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.externalId = _data["externalId"];
            this.optionName = _data["optionName"];
            this.optionsComment = _data["optionsComment"];
            this.product = _data["product"] ? ProductData.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductDeliveryOption {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDeliveryOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["externalId"] = this.externalId;
        data["optionName"] = this.optionName;
        data["optionsComment"] = this.optionsComment;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductDeliveryOption {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    optionName?: string | undefined;
    optionsComment?: string | undefined;
    product?: ProductData | undefined;
}

export class ProductAttribute implements IProductAttribute {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    attributeName?: string | undefined;
    attributeGroup?: string | undefined;
    attributeValues?: string | undefined;
    product?: ProductData | undefined;

    constructor(data?: IProductAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productId = _data["productId"];
            this.externalId = _data["externalId"];
            this.attributeName = _data["attributeName"];
            this.attributeGroup = _data["attributeGroup"];
            this.attributeValues = _data["attributeValues"];
            this.product = _data["product"] ? ProductData.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productId"] = this.productId;
        data["externalId"] = this.externalId;
        data["attributeName"] = this.attributeName;
        data["attributeGroup"] = this.attributeGroup;
        data["attributeValues"] = this.attributeValues;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductAttribute {
    id?: number;
    productId?: number | undefined;
    externalId?: number;
    attributeName?: string | undefined;
    attributeGroup?: string | undefined;
    attributeValues?: string | undefined;
    product?: ProductData | undefined;
}

export class ResponseCompany implements IResponseCompany {
    id?: number;
    externalId?: string | undefined;
    productCount?: number;
    name?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;

    constructor(data?: IResponseCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.productCount = _data["productCount"];
            this.name = _data["name"];
            this.url = _data["url"];
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponseCompany {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseCompany();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["productCount"] = this.productCount;
        data["name"] = this.name;
        data["url"] = this.url;
        data["syncDate"] = this.syncDate ? this.syncDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IResponseCompany {
    id?: number;
    externalId?: string | undefined;
    productCount?: number;
    name?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
}

export class ProductJson implements IProductJson {
    title?: string | undefined;
    externalId?: string | undefined;
    url?: string | undefined;
    currency?: string | undefined;
    keyWords?: string | undefined;
    description?: string | undefined;
    price?: string | undefined;
    priceUsd?: string | undefined;
    scuCode?: string | undefined;
    fullPrice?: string | undefined;
    isDiscounted?: boolean;
    discountPercent?: number | undefined;
    presence?: PresenceData | undefined;
    optPrice?: string | undefined;
    imageUrls?: string[] | undefined;
    syncDate?: Date;
    expirationDate?: Date;
    jsonCategory?: string | undefined;
    stringCategory?: string | undefined;
    jsonCategorySchema?: string | undefined;
    productAttribute?: ProductAttribute[] | undefined;
    productPaymentOptions?: ProductPaymentOption[] | undefined;
    productDeliveryOptions?: ProductDeliveryOption[] | undefined;

    constructor(data?: IProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.externalId = _data["externalId"];
            this.url = _data["url"];
            this.currency = _data["currency"];
            this.keyWords = _data["keyWords"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.priceUsd = _data["priceUsd"];
            this.scuCode = _data["scuCode"];
            this.fullPrice = _data["fullPrice"];
            this.isDiscounted = _data["isDiscounted"];
            this.discountPercent = _data["discountPercent"];
            this.presence = _data["presence"] ? PresenceData.fromJS(_data["presence"]) : <any>undefined;
            this.optPrice = _data["optPrice"];
            if (Array.isArray(_data["imageUrls"])) {
                this.imageUrls = [] as any;
                for (let item of _data["imageUrls"])
                    this.imageUrls!.push(item);
            }
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.expirationDate = _data["expirationDate"] ? new Date(_data["expirationDate"].toString()) : <any>undefined;
            this.jsonCategory = _data["jsonCategory"];
            this.stringCategory = _data["stringCategory"];
            this.jsonCategorySchema = _data["jsonCategorySchema"];
            if (Array.isArray(_data["productAttribute"])) {
                this.productAttribute = [] as any;
                for (let item of _data["productAttribute"])
                    this.productAttribute!.push(ProductAttribute.fromJS(item));
            }
            if (Array.isArray(_data["productPaymentOptions"])) {
                this.productPaymentOptions = [] as any;
                for (let item of _data["productPaymentOptions"])
                    this.productPaymentOptions!.push(ProductPaymentOption.fromJS(item));
            }
            if (Array.isArray(_data["productDeliveryOptions"])) {
                this.productDeliveryOptions = [] as any;
                for (let item of _data["productDeliveryOptions"])
                    this.productDeliveryOptions!.push(ProductDeliveryOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new ProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["externalId"] = this.externalId;
        data["url"] = this.url;
        data["currency"] = this.currency;
        data["keyWords"] = this.keyWords;
        data["description"] = this.description;
        data["price"] = this.price;
        data["priceUsd"] = this.priceUsd;
        data["scuCode"] = this.scuCode;
        data["fullPrice"] = this.fullPrice;
        data["isDiscounted"] = this.isDiscounted;
        data["discountPercent"] = this.discountPercent;
        data["presence"] = this.presence ? this.presence.toJSON() : <any>undefined;
        data["optPrice"] = this.optPrice;
        if (Array.isArray(this.imageUrls)) {
            data["imageUrls"] = [];
            for (let item of this.imageUrls)
                data["imageUrls"].push(item);
        }
        data["syncDate"] = this.syncDate ? this.syncDate.toISOString() : <any>undefined;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["jsonCategory"] = this.jsonCategory;
        data["stringCategory"] = this.stringCategory;
        data["jsonCategorySchema"] = this.jsonCategorySchema;
        if (Array.isArray(this.productAttribute)) {
            data["productAttribute"] = [];
            for (let item of this.productAttribute)
                data["productAttribute"].push(item.toJSON());
        }
        if (Array.isArray(this.productPaymentOptions)) {
            data["productPaymentOptions"] = [];
            for (let item of this.productPaymentOptions)
                data["productPaymentOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.productDeliveryOptions)) {
            data["productDeliveryOptions"] = [];
            for (let item of this.productDeliveryOptions)
                data["productDeliveryOptions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductJson {
    title?: string | undefined;
    externalId?: string | undefined;
    url?: string | undefined;
    currency?: string | undefined;
    keyWords?: string | undefined;
    description?: string | undefined;
    price?: string | undefined;
    priceUsd?: string | undefined;
    scuCode?: string | undefined;
    fullPrice?: string | undefined;
    isDiscounted?: boolean;
    discountPercent?: number | undefined;
    presence?: PresenceData | undefined;
    optPrice?: string | undefined;
    imageUrls?: string[] | undefined;
    syncDate?: Date;
    expirationDate?: Date;
    jsonCategory?: string | undefined;
    stringCategory?: string | undefined;
    jsonCategorySchema?: string | undefined;
    productAttribute?: ProductAttribute[] | undefined;
    productPaymentOptions?: ProductPaymentOption[] | undefined;
    productDeliveryOptions?: ProductDeliveryOption[] | undefined;
}

export class ResponseProduct implements IResponseProduct {
    id?: number;
    externalId?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    description?: string | undefined;
    price?: string | undefined;

    constructor(data?: IResponseProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.externalId = _data["externalId"];
            this.title = _data["title"];
            this.url = _data["url"];
            this.syncDate = _data["syncDate"] ? new Date(_data["syncDate"].toString()) : <any>undefined;
            this.description = _data["description"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any): ResponseProduct {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["externalId"] = this.externalId;
        data["title"] = this.title;
        data["url"] = this.url;
        data["syncDate"] = this.syncDate ? this.syncDate.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["price"] = this.price;
        return data; 
    }
}

export interface IResponseProduct {
    id?: number;
    externalId?: string | undefined;
    title?: string | undefined;
    url?: string | undefined;
    syncDate?: Date;
    description?: string | undefined;
    price?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}